# 멀티플레이어 개발 계획: 웹소켓 서버 (Node.js) 및 언리얼 클라이언트 (C++)

이 문서는 웹소켓 서버와 언리얼 클라이언트 간의 멀티플레이어 환경 구축을 위한 향후 구현 계획을 구체적으로 설명합니다.

## 1. 웹소켓 서버 (Node.js / JavaScript) 구현 계획

웹소켓 서버는 게임의 핵심 로직을 처리하고 모든 클라이언트 간의 상태를 동기화하는 권한 있는(authoritative) 역할을 수행합니다.

### 1.1. 연결 관리 (Connection Management)
*   **클라이언트 연결/해제 처리:** 새로운 클라이언트의 접속 및 연결 해제를 안정적으로 처리합니다.
*   **고유 ID 할당:** 각 연결된 클라이언트에게 고유한 세션 ID를 할당하고 관리합니다.
*   **활성 클라이언트 목록 유지:** 현재 접속 중인 모든 클라이언트의 목록과 관련 데이터를 효율적으로 관리합니다.

### 1.2. 데이터 브로드캐스팅 (Data Broadcasting)
*   **플레이어 트랜스폼 데이터 전파:** 모든 클라이언트 또는 특정 범위 내의 클라이언트에게 플레이어의 위치, 회전, 스케일 데이터를 효율적으로 브로드캐스팅합니다. (예: 관심 영역(Area of Interest) 기반 브로드캐스팅)
*   **채팅 메시지 전파:** 모든 클라이언트에게 채팅 메시지를 브로드캐스팅합니다.
*   **게임 상태 변경 전파:** 게임 오브젝트의 생성/파괴, 상호작용, 이벤트 발생 등 중요한 게임 상태 변경 사항을 클라이언트에게 전파합니다.

### 1.3. 게임 상태 관리 (Game State Management)
*   **권한 있는 게임 로직:** 플레이어의 체력, 점수, 아이템 획득, 상호작용, 스킬 사용 등 모든 핵심 게임 로직을 서버에서 처리하여 치트 방지 및 일관성 유지를 보장합니다.
*   **게임 오브젝트 동기화:** 플레이어가 아닌 게임 오브젝트(예: 적 AI, 맵 상의 아이템, 문 등)의 상태를 관리하고 클라이언트와 동기화합니다.
*   **게임 규칙 및 승패 조건 처리:** 게임의 시작/종료, 승패 조건 판정, 라운드 관리 등을 서버에서 담당합니다.

### 1.4. 입력 유효성 검사 (Input Validation)
*   **클라이언트 입력 검증:** 클라이언트로부터 수신되는 모든 플레이어 입력(이동, 액션 등)이 유효한지 서버에서 검증하여 속도 핵, 순간이동 등과 같은 치트 행위를 방지합니다.

### 1.5. 데이터 영속성 (Persistence) (선택 사항)
*   **플레이어 데이터 저장/로드:** 플레이어 계정 정보, 인벤토리, 진행 상황 등을 데이터베이스에 저장하고 로드하는 기능을 구현합니다.
*   **게임 상태 저장/로드:** 필요한 경우 게임 세션의 상태를 저장하고 다시 로드할 수 있는 기능을 구현합니다.

### 1.6. 오류 처리 및 로깅 (Error Handling & Logging)
*   **견고한 오류 처리:** 네트워크 단절, 잘못된 데이터 수신, 서버 로직 오류 등에 대한 견고한 오류 처리 메커니즘을 구현합니다.
*   **서버 활동 로깅:** 서버의 주요 활동, 경고, 오류 등을 기록하여 문제 진단 및 성능 모니터링에 활용합니다.

---

## 2. 언리얼 클라이언트 (C++) 구현 계획

언리얼 클라이언트는 서버로부터 받은 데이터를 기반으로 게임 월드를 렌더링하고, 플레이어의 입력을 서버로 전송하며, 사용자 경험을 제공합니다.

### 2.1. 플레이어 입력 및 이동 (Player Input & Movement)
*   **로컬 플레이어 입력 전송:** 로컬 플레이어의 입력(키보드, 마우스 등) 및 현재 트랜스폼 데이터를 서버로 효율적으로 전송합니다.
*   **클라이언트 측 예측 (Client-Side Prediction):** 로컬 플레이어의 움직임을 클라이언트에서 즉시 예측하여 입력 지연(latency)을 마스킹하고 부드러운 조작감을 제공합니다.
*   **서버 위치 보정 (Reconciliation):** 서버로부터 받은 권한 있는 위치와 클라이언트 예측 위치 간의 불일치를 감지하고 보정하여 게임 상태의 일관성을 유지합니다.

### 2.2. 원격 플레이어 관리 (Remote Player Management)
*   **원격 플레이어 스폰/파괴:** 서버 데이터에 따라 `AMyRemoteCharacter` 인스턴스를 동적으로 생성하고 파괴합니다.
*   **부드러운 움직임 보간/외삽 (Interpolation/Extrapolation):** 서버로부터 수신되는 원격 플레이어의 트랜스폼 데이터를 기반으로 움직임을 부드럽게 보간(interpolation)하거나 예측(extrapolation)하여 끊김 없는 시각적 경험을 제공합니다.
*   **복제된 속성 처리:** 원격 플레이어의 체력, 애니메이션 상태, 장비, 코스튬 등 서버로부터 복제된 다양한 속성을 올바르게 적용하고 표시합니다.

### 2.3. 게임 상태 동기화 (Game State Synchronization)
*   **권한 있는 게임 상태 업데이트 수신:** 서버로부터 전송되는 게임 오브젝트(아이템, 적 AI, 환경 상호작용 요소 등)의 권한 있는 상태 업데이트를 수신하고 클라이언트 월드에 적용합니다.
*   **게임 오브젝트 관리:** 서버 데이터에 따라 클라이언트 측에서 게임 오브젝트를 생성, 업데이트, 파괴합니다.

### 2.4. UI 피드백 (UI Feedback)
*   **플레이어 목록 및 점수판:** 현재 접속 중인 플레이어 목록, 점수, 팀 정보 등을 표시하는 UI를 구현합니다.
*   **체력/자원 바:** 플레이어 및 중요한 게임 오브젝트의 체력, 마나, 자원 등을 시각적으로 표시하는 UI를 구현합니다.
*   **채팅 UI:** 기존 채팅 기능을 확장하여 메시지 표시, 입력, 전송을 위한 사용자 친화적인 UI를 제공합니다.
*   **연결 상태 표시:** 네트워크 연결 상태(예: 연결됨, 연결 끊김, 핑)를 사용자에게 시각적으로 피드백합니다.

### 2.5. 오류 처리 및 지연 보상 (Error Handling & Latency Compensation)
*   **네트워크 단절 처리:** 서버와의 연결이 끊겼을 때 사용자에게 알리고 적절한 조치(예: 메인 메뉴로 돌아가기)를 취합니다.
*   **높은 지연 시간 시각화:** 높은 핑(ping) 또는 패킷 손실이 발생할 경우 사용자에게 시각적인 경고를 제공합니다.

### 2.6. 애니메이션 및 시각 효과 (Animation & Visuals)
*   **애니메이션 동기화:** 플레이어의 움직임, 액션, 스킬 사용 등에 따라 로컬 및 원격 플레이어의 애니메이션을 동기화하고 재생합니다.
*   **장비 및 코스튬:** 플레이어가 장착한 장비나 코스튬을 시각적으로 표시하고 동기화합니다.
*   **시각 효과:** 스킬 이펙트, 피격 효과 등 다양한 시각 효과를 서버 데이터에 따라 클라이언트에서 재생합니다.

---

### 3. 구현 단계별 계획 (소규모 발표용)

이 계획은 대규모 및 높은 보안 수준이 요구되지 않는 소규모 발표를 목표로, 핵심 멀티플레이어 기능을 순차적으로 구현하는 데 중점을 둡니다.

#### 3.1. 1단계: 핵심 플레이어 동기화 (MVP)

*   **목표:** 최소한의 기능으로 여러 플레이어가 같은 공간에서 서로의 움직임을 보고 채팅할 수 있도록 합니다.
*   **서버 (Node.js):**
    *   **연결 관리:** 클라이언트 연결/해제, 고유 ID 할당, 활성 클라이언트 목록 유지.
    *   **데이터 브로드캐스팅:** 플레이어 트랜스폼 데이터 (위치, 회전) 및 채팅 메시지를 모든 클라이언트에게 브로드캐스팅.
    *   **입력 유효성 검사:** 기본적인 트랜스폼 데이터 유효성 검사 (예: 숫자 형식 확인).
*   **클라이언트 (Unreal C++):**
    *   **플레이어 입력 및 이동:** 로컬 플레이어의 트랜스폼 데이터를 서버로 전송.
    *   **원격 플레이어 관리:** 서버 데이터에 따라 `AMyRemoteCharacter` 스폰/파괴, 트랜스폼 업데이트 및 보간.
    *   **UI 피드백:** 채팅 UI (기존 기능 활용).
    *   **오류 처리:** 기본적인 연결/단절 메시지 표시.

#### 3.2. 2단계: 상호작용 및 시각적 개선

*   **목표:** 플레이어 간의 간단한 상호작용을 추가하고, 캐릭터의 시각적 표현을 개선하여 발표의 완성도를 높입니다.
*   **서버 (Node.js):**
    *   **게임 상태 관리:** 간단한 상호작용 이벤트 처리 (예: 아이템 줍기, 문 열기 등) 및 결과 브로드캐스팅.
    *   **데이터 브로드캐스팅:** 상호작용 이벤트 결과 브로드캐스팅.
*   **클라이언트 (Unreal C++):**
    *   **원격 플레이어 관리:** 원격 플레이어의 애니메이션 동기화 (예: 걷기/뛰기, 점프).
    *   **게임 상태 동기화:** 서버로부터 받은 상호작용 이벤트 처리 및 시각적 피드백 (예: 아이템 획득 애니메이션, 문 열림).
    *   **UI 피드백:** 플레이어 이름 표시 (네임태그), 간단한 상호작용 메시지.
    *   **애니메이션 및 시각 효과:** 로컬 및 원격 플레이어의 기본 애니메이션 (이동, 점프) 구현.

#### 3.3. 3단계: 안정성 및 확장성 고려 (발표 후 개선)

*   **목표:** 발표 이후, 실제 게임 개발을 위한 안정성과 확장성을 점진적으로 확보합니다.
*   **서버 (Node.js):**
    *   **게임 상태 관리:** 권한 있는 게임 로직 확장 (예: 공격 판정, 스킬 사용, 점수 시스템).
    *   **입력 유효성 검사:** 고급 치트 방지 로직 (예: 속도 제한, 위치 검증).
    *   **데이터 영속성:** 플레이어 데이터 저장/로드 (선택 사항).
    *   **오류 처리 및 로깅:** 상세 로깅 및 모니터링 시스템 구축.
*   **클라이언트 (Unreal C++):**
    *   **클라이언트 측 예측:** 고급 클라이언트 측 예측 및 서버 보정 로직 구현.
    *   **원격 플레이어 관리:** 장비/코스튬 동기화, 더 복잡한 애니메이션 상태 처리.
    *   **UI 피드백:** 플레이어 목록, 점수판, 상세 정보 UI.
    *   **오류 처리 및 지연 보상:** 네트워크 지연 시각화, 연결 끊김 시 복구 로직.